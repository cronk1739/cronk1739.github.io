<!DOCTYPE HTML>
<html>
    <head>
        <title>My First Website</title>
        <link rel="stylesheet" href="style.css">
    </head>

    <body>
        <div id="desktop">
            <div id="icons">
                <div class="icon" data-href="settings" data-color="#3b82f6" tabindex="0">
                    <img class="app-icon" src="https://images.vexels.com/media/users/3/143276/isolated/preview/98336182a8a47d620c44bc80a1a4abdc-cog-wheel.png" alt="Settings" />
                    <span>Settings</span>
                </div>
                <div class="icon" data-href="portfolio.html" data-color="#10b981" tabindex="0">
                    <span class="glyph folder green"></span>
                    <span>Portfolio</span>
                </div>
                <div class="icon" data-href="images.html" data-color="#ef4444" tabindex="0">
                    <img class="app-icon" src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRLvwmXlstUSTVmA0C2KWphEIlqJr1mk3ySrQ&s" alt="Images" />
                    <span>Images</span>
                </div>
                <div class="icon" data-href="newer-mini-projects/mini-projects/drawing-app/drawing.html" data-color="#8b5cf6" tabindex="0">
                    <img class="app-icon" src="assets/drawing-icon.svg" alt="Drawing" />
                    <span>Drawing</span>
                </div>
                <div class="icon" data-href="newer-mini-projects/music-app/index.html" data-color="#ef4444" tabindex="0">
                    <img class="app-icon" src="assets/musicnote.png" alt="Music" />
                    <span>Music</span>
                </div>
                <div class="icon" data-href="studies.html" data-color="#f59e0b" tabindex="0">
                    <img class="app-icon" src="assets/iconbook.png" alt="Studies" />
                    <span>Studies</span>
                </div>
                <div class="icon" data-href="calculator.html" data-color="#6366f1" tabindex="0">
                    <span class="glyph folder indigo"></span>
                    <span>Calculator</span>
                </div>
                <!-- Secret icon removed per request -->
            </div>

            <div id="taskbar">
                <button id="start-button">Start</button>
                <div id="taskbar-icons"></div>
                <div id="tray">
                    <div id="clock"></div>
                </div>
            </div>

            <div id="windows"></div>

            <div id="start-menu" hidden>
                <div class="start-header">Start Menu</div>
                <ul>
                    <li><a href="index.html">Home</a></li>
                    <li><a href="#" id="start-settings">Settings</a></li>
                    <li><a href="newer-mini-projects/mini-projects/drawing-app/drawing.html">Drawing</a></li>
                    <li><a href="newer-mini-projects/music-app/index.html">Music</a></li>
                </ul>
            </div>
        </div>

        <script>
        // Desktop icon interactions
            (function(){
            const icons = document.querySelectorAll('.icon');
            const iconsWrap = document.getElementById('icons');

            // make icons container positioning context for absolute-placed icons
            if(getComputedStyle(iconsWrap).position === 'static') iconsWrap.style.position = 'relative';

            // load saved icon positions from localStorage
            function loadIconPositions(){
                try{
                    const raw = localStorage.getItem('desktopIconPositions');
                    if(!raw) return {};
                    return JSON.parse(raw);
                }catch(e){ return {}; }
            }
            function saveIconPositions(map){
                try{ localStorage.setItem('desktopIconPositions', JSON.stringify(map)); }catch(e){}
            }
            const savedPositions = loadIconPositions();
            // apply saved positions (if any)
            icons.forEach(icon=>{
                const key = icon.dataset.href || icon.textContent.trim();
                const pos = savedPositions[key];
                if(pos && typeof pos.left === 'number' && typeof pos.top === 'number'){
                    icon.style.position = 'absolute';
                    icon.style.left = pos.left + 'px';
                    icon.style.top = pos.top + 'px';
                }
            });
            const windows = document.getElementById('windows');
            const taskbarIcons = document.getElementById('taskbar-icons');
            let topZ = 1000;

            function createWindow(title, href, color = '#6b7280'){
                const win = document.createElement('div');
                win.className = 'window opening';
                // build window titlebar and controls (no Home button)
                win.innerHTML = `<div class="titlebar"><span class="title">${title}</span><div class="title-actions"><button class="minimize">–</button><button class="fullscreen" aria-pressed="false">▢</button><button class="close">✕</button></div></div><div class="content"><div class="iframe-wrap"><iframe src="${href}" frameborder="0"></iframe></div></div><div class="resizer" aria-hidden="true"></div>`;
                windows.appendChild(win);
                win.style.zIndex = ++topZ;

                // taskbar button
                const taskBtn = document.createElement('button');
                taskBtn.className = 'task-btn';
                taskBtn.innerHTML = `<span class="task-icon" style="background:${color}; box-shadow: inset 0 -2px rgba(0,0,0,0.12);"></span>`;
                taskBtn.title = title;
                taskbarIcons.appendChild(taskBtn);

                const close = win.querySelector('.close');
                close.addEventListener('click', ()=>{ try{ win.remove(); }catch(e){} try{ taskBtn.remove(); }catch(e){} });

                // cleanup embedded page UI when iframe loads
                const iframe = win.querySelector('iframe');
                iframe.addEventListener('load', ()=>{
                    try{
                        const idoc = iframe.contentDocument || iframe.contentWindow.document;
                        // hide common desktop elements inside embedded pages
                        const selectors = ['header.section','nav','#taskbar','#start-menu','#icons','footer','.section .nav'];
                        selectors.forEach(sel=>{
                            const el = idoc.querySelector(sel);
                            if(el) el.style.display = 'none';
                        });
                        // remove body margins to reduce whitespace
                        if(idoc.body) idoc.body.style.margin = '0';
                        // also try to reduce padding on first .section if present
                        const firstSection = idoc.querySelector('.section');
                        if(firstSection) { firstSection.style.paddingTop = '6px'; firstSection.style.paddingBottom = '6px'; }
                    }catch(e){}
                });

                // center window
                const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
                const vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);
                // default window size; some apps (music) prefer a wider layout
                let initW = 640, initH = 420;
                try{
                    // if opening the music app, use a larger default size
                    if(String(href).includes('newer-mini-projects/music-app')){ initW = 900; initH = 520; }
                }catch(e){}
                win.style.position='absolute'; win.style.width = initW + 'px'; win.style.height = initH + 'px'; win.style.left = Math.max(10, Math.floor((vw - initW)/2)) + 'px'; win.style.top = Math.max(10, Math.floor((vh - initH)/2)) + 'px';

                // bring to front on pointerdown
                win.addEventListener('pointerdown', ()=> win.style.zIndex = ++topZ);

                // draggable
                (function(){
                    const bar = win.querySelector('.titlebar');
                    let pid=null, sx=0, sy=0, ox=0, oy=0;
                    function mv(e){ if(e.pointerId!==pid) return; win.style.left = (ox + e.clientX - sx) + 'px'; win.style.top = (oy + e.clientY - sy) + 'px'; }
                    function up(e){ if(e.pointerId!==pid) return; try{ bar.releasePointerCapture(pid);}catch(err){} pid=null; document.removeEventListener('pointermove', mv); document.removeEventListener('pointerup', up); }
                    bar.addEventListener('pointerdown', (e)=>{
                        // don't start drag when clicking controls
                        if(e.target.closest('button') || e.target.closest('.title-actions')) return;
                        pid=e.pointerId; bar.setPointerCapture(pid); sx=e.clientX; sy=e.clientY; const r=win.getBoundingClientRect(); ox=r.left; oy=r.top; document.addEventListener('pointermove', mv); document.addEventListener('pointerup', up);
                    });
                    // double-click titlebar to toggle fullscreen
                    bar.addEventListener('dblclick', ()=>{ const fs = win.querySelector('.fullscreen'); if(fs) fs.click(); });
                })();

                // resizer
                (function(){ const resizer = win.querySelector('.resizer'); let rid=null, sx=0, sy=0, sw=0, sh=0; function mv(e){ if(e.pointerId!==rid) return; win.style.width = Math.max(300, sw + e.clientX - sx) + 'px'; win.style.height = Math.max(200, sh + e.clientY - sy) + 'px'; } function up(e){ if(e.pointerId!==rid) return; try{ resizer.releasePointerCapture(rid);}catch(err){} rid=null; document.removeEventListener('pointermove', mv); document.removeEventListener('pointerup', up); } resizer.addEventListener('pointerdown', (e)=>{ rid=e.pointerId; resizer.setPointerCapture(rid); sx=e.clientX; sy=e.clientY; const r=win.getBoundingClientRect(); sw=r.width; sh=r.height; document.addEventListener('pointermove', mv); document.addEventListener('pointerup', up); }); })();

                                // minimize
                                const minBtn = win.querySelector('.minimize'); minBtn.addEventListener('click', ()=>{ win.style.display='none'; taskBtn.classList.add('minimized'); });
                                // fullscreen
                                const fsBtn = win.querySelector('.fullscreen');
                                let maximized = false; let prevRect = null;
                                function toggleFullscreen(){
                                    if(!maximized){
                                        const rect = win.getBoundingClientRect();
                                        prevRect = {left: rect.left, top: rect.top, width: rect.width, height: rect.height};
                                        // make truly fullscreen within viewport
                                        win.classList.add('fullscreen');
                                        maximized = true; fsBtn.setAttribute('aria-pressed','true');
                                    } else {
                                        if(prevRect){ win.style.position='absolute'; win.style.left=prevRect.left+'px'; win.style.top=prevRect.top+'px'; win.style.width=prevRect.width+'px'; win.style.height=prevRect.height+'px'; }
                                        win.classList.remove('fullscreen');
                                        maximized=false; fsBtn.setAttribute('aria-pressed','false');
                                    }
                                    win.style.zIndex = ++topZ;
                                }
                                fsBtn.addEventListener('click', toggleFullscreen);
                taskBtn.addEventListener('click', ()=>{
                    // if minimized, restore and focus
                    if(win.style.display==='none' || win.classList.contains('minimized')){
                        win.style.display='block'; taskBtn.classList.remove('minimized'); win.style.zIndex = ++topZ; win.classList.remove('minimized');
                    } else {
                        // if visible, minimize it
                        win.style.display='none'; taskBtn.classList.add('minimized'); win.classList.add('minimized');
                    }
                });

                setTimeout(()=> win.classList.remove('opening'), 260);
                return win;
            }

            icons.forEach(icon=>{
                let clickCount = 0; let clickTimer = null;
                // drag state for this icon
                let dragState = { dragging:false, moved:false, pid:null, sx:0, sy:0, startLeft:0, startTop:0 };

                // pointerdown to start Alt+drag move
                icon.addEventListener('pointerdown', (e)=>{
                    // only start move when Alt is pressed
                    if(!e.altKey) return;
                    e.preventDefault();
                    dragState.dragging = true; dragState.pid = e.pointerId; dragState.sx = e.clientX; dragState.sy = e.clientY;
                    // ensure icon is absolutely positioned relative to iconsWrap
                    const wrapRect = iconsWrap.getBoundingClientRect();
                    const iconRect = icon.getBoundingClientRect();
                    // compute left/top relative to wrap
                    const curLeft = iconRect.left - wrapRect.left + iconsWrap.scrollLeft;
                    const curTop = iconRect.top - wrapRect.top + iconsWrap.scrollTop;
                    // set absolute positioning if not already
                    if(getComputedStyle(icon).position !== 'absolute'){
                        icon.style.position = 'absolute';
                        icon.style.left = Math.round(curLeft) + 'px';
                        icon.style.top = Math.round(curTop) + 'px';
                    }
                    dragState.startLeft = parseFloat(icon.style.left) || 0; dragState.startTop = parseFloat(icon.style.top) || 0;
                    icon.setPointerCapture(dragState.pid);

                    function onMove(ev){ if(!dragState.dragging || ev.pointerId !== dragState.pid) return; const dx = ev.clientX - dragState.sx; const dy = ev.clientY - dragState.sy; const rawLeft = Math.max(0, Math.round(dragState.startLeft + dx)); const rawTop = Math.max(0, Math.round(dragState.startTop + dy)); const GRID = 16; const newLeft = Math.round(rawLeft / GRID) * GRID; const newTop = Math.round(rawTop / GRID) * GRID; icon.style.left = newLeft + 'px'; icon.style.top = newTop + 'px'; dragState.moved = true; }
                    function onUp(ev){ if(ev.pointerId !== dragState.pid) return; try{ icon.releasePointerCapture(dragState.pid);}catch(err){} dragState.dragging = false; dragState.pid = null; document.removeEventListener('pointermove', onMove); document.removeEventListener('pointerup', onUp);
                        // persist positions
                        const positions = loadIconPositions();
                        const key = icon.dataset.href || icon.textContent.trim();
                        positions[key] = { left: Math.round((parseFloat(icon.style.left)||0)), top: Math.round((parseFloat(icon.style.top)||0)) };
                        saveIconPositions(positions);
                        // mark moved briefly to suppress click/dblclick
                        icon.dataset.moved = '1'; setTimeout(()=>{ delete icon.dataset.moved; }, 150);
                    }

                    document.addEventListener('pointermove', onMove);
                    document.addEventListener('pointerup', onUp);
                });

                icon.addEventListener('click', (e)=>{
                    // ignore click if this icon was just moved
                    if(icon.dataset.moved) return;
                    clickCount++; if(clickCount===1){ icon.classList.toggle('selected'); clickTimer = setTimeout(()=>{ clickCount=0; }, 300); } else if(clickCount===2){ clearTimeout(clickTimer); clickCount=0; const href = icon.dataset.href; if(href){ if(href === 'settings'){ createSettingsWindow(); } else { createWindow(icon.textContent.trim(), href); } }
                    }
                });
                icon.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ const href = icon.dataset.href; if(href){ if(href === 'settings'){ createSettingsWindow(); } else { createWindow(icon.textContent.trim(), href); } } } });
            });

            // special handling for settings icon (open internal settings UI)
            const settingsIcon = document.querySelector('.icon[data-href="settings"]');

            // helper to inject Google Font stylesheet link into the page (idempotent)
            function injectGoogleFont(family){
                if(!family) return;
                const fam = encodeURIComponent(family.trim().replace(/\s+/g,' '));
                const href = `https://fonts.googleapis.com/css2?family=${fam}:wght@400;700&display=swap`;
                const prev = document.querySelector('link[data-google-font]'); if(prev) prev.remove();
                const link = document.createElement('link'); link.rel='stylesheet'; link.href = href; link.setAttribute('data-google-font', family);
                document.head.appendChild(link);
            }

            function applySettings(settings){
                if(!settings) return;
                if(settings.googleFont) {
                    try{ injectGoogleFont(settings.googleFont); }catch(e){}
                }
                if(settings.fontFamily){
                    // set CSS variable for themes
                    document.documentElement.style.setProperty('--desktop-font', settings.fontFamily);
                    // immediate fallback for older CSS engines: set body font directly
                    try{ document.body.style.fontFamily = settings.fontFamily; }catch(e){}
                }
                if(settings.wallpaper){ document.getElementById('desktop').style.backgroundImage = `url('${settings.wallpaper}')`; }
                if(settings.taskbarColor){ const taskbar = document.getElementById('taskbar'); if(taskbar){ const color = settings.taskbarColor; const opacity = parseFloat(settings.taskbarOpacity || 1); const r = parseInt(color.slice(1, 3), 16); const g = parseInt(color.slice(3, 5), 16); const b = parseInt(color.slice(5, 7), 16); taskbar.style.setProperty('background', `rgba(${r}, ${g}, ${b}, ${opacity})`, 'important'); } }
                if(settings.iconStyle){ const taskbar = document.getElementById('taskbar'); if(taskbar) { taskbar.classList.remove('icon-square', 'icon-circle', 'icon-rounded'); if(settings.iconStyle !== 'square') taskbar.classList.add('icon-' + settings.iconStyle); } }
                if(settings.appIcons){
                    // Apply custom app icons
                    const iconMap = {
                        'settings': '[data-href="settings"]',
                        'portfolio': '[data-href="portfolio.html"]',
                        'images': '[data-href="images.html"]',
                        'drawing': '[data-href="newer-mini-projects/mini-projects/drawing-app/drawing.html"]',
                        'music': '[data-href="newer-mini-projects/music-app/index.html"]',
                        'studies': '[data-href="studies.html"]',
                        'calculator': '[data-href="calculator.html"]'
                    };
                    Object.keys(settings.appIcons).forEach(appId => {
                        const selector = iconMap[appId];
                        if(selector) {
                            const iconEl = document.querySelector('.icon' + selector);
                            if(iconEl) {
                                const customIcon = settings.appIcons[appId];
                                const existingImg = iconEl.querySelector('.app-icon');
                                const existingGlyph = iconEl.querySelector('.glyph');
                                const existingCustom = iconEl.querySelectorAll('.app-icon-custom');
                                
                                // Remove all existing custom icons
                                existingCustom.forEach(el => el.remove());
                                
                                // Check if it's a URL (contains / or .)
                                const isUrl = customIcon.includes('/') || customIcon.includes('.');
                                
                                if(!isUrl) {
                                    // Emoji or text
                                    if(existingImg) existingImg.remove();
                                    if(existingGlyph) existingGlyph.remove();
                                    // Add as text/emoji
                                    const iconSpan = document.createElement('span');
                                    iconSpan.className = 'app-icon-custom';
                                    iconSpan.textContent = customIcon;
                                    iconSpan.style.fontSize = '28px';
                                    iconSpan.style.display = 'block';
                                    iconSpan.style.lineHeight = '1';
                                    iconSpan.style.marginBottom = '2px';
                                    iconEl.insertBefore(iconSpan, iconEl.querySelector('span'));
                                } else {
                                    // URL - treat as image
                                    if(existingGlyph) existingGlyph.remove();
                                    if(existingImg) {
                                        existingImg.src = customIcon;
                                    } else {
                                        const img = document.createElement('img');
                                        img.className = 'app-icon';
                                        img.src = customIcon;
                                        img.alt = 'App Icon';
                                        img.style.width = '32px';
                                        img.style.height = '32px';
                                        img.style.objectFit = 'contain';
                                        img.style.marginBottom = '2px';
                                        iconEl.insertBefore(img, iconEl.querySelector('span'));
                                    }
                                }
                            }
                        }
                    });
                }
            }
            function saveSettings(settings){ localStorage.setItem('desktopSettings', JSON.stringify(settings)); applySettings(settings); }
            function loadSettings(){ try{ return JSON.parse(localStorage.getItem('desktopSettings')||'{}'); }catch(e){ return {}; } }
            function createSettingsWindow(){
                // build a simple in-page settings window (not iframe)
                const existing = document.querySelector('.window[data-settings]'); if(existing){ existing.style.zIndex = ++topZ; return existing; }
                const win = document.createElement('div'); win.className = 'window opening'; win.setAttribute('data-settings','true');
                win.innerHTML = `<div class="titlebar"><span class="title">Settings</span><div class="title-actions"><button class="minimize">–</button><button class="fullscreen">⛶</button><button class="close">✕</button></div></div><div class="content"><div class="settings-form"><label>Font: <select id="font-select"><option value="'Segoe UI', Tahoma, Geneva, Verdana, sans-serif">Default</option><option value="Arial, Helvetica, sans-serif">Arial</option><option value="'Courier New', monospace">Monospace</option><option value="Georgia, serif">Serif</option><option value="'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial">Inter</option><option value="'Poppins', system-ui, -apple-system, Roboto, 'Helvetica Neue', Arial">Poppins</option><option value="'Lato', system-ui, Roboto, 'Helvetica Neue', Arial">Lato</option><option value="'Montserrat', system-ui, Roboto, 'Helvetica Neue', Arial">Montserrat</option></select></label><label>Custom font stack (CSS): <input id="custom-stack-input" placeholder="e.g. 'Segoe UI', system-ui, sans-serif" /></label><div id="settings-preview" class="settings-preview">The quick brown fox jumps over the lazy dog — Preview text</div><label>Wallpaper: <select id="wallpaper-select"><option value="assets/bliss.jpg">Bliss (Default)</option><option value="assets/img_EliChristianMartin.JPG">Eli Christian Martin</option><option value="assets/img_Kawaiilittleboy.JPG">Kawaii Little Boy</option><option value="assets/img_MineCraftStevedeath.JPG">Minecraft Steve Death</option><option value="assets/img_RandomGuy.JPG">Random Guy</option><option value="assets/img_SkibidiTrashcanSebastian.JPG">Skibidi Trashcan Sebastian</option><option value="assets/img_StairGremlin.JPG">Stair Gremlin</option><option value="assets/img_SuperRichTeacher.JPG">Super Rich Teacher</option><option value="assets/img_TheLioneatsthesmallchild.JPG">The Lion Eats The Small Child</option><option value="assets/img_ThugBoy89.JPG">Thug Boy 89</option><option value="assets/img_Vendermachine.JPG">Vender Machine</option><option value="custom">Custom URL</option></select></label><input id="wallpaper-input" placeholder="Custom wallpaper URL" style="display:none;" /><label>Taskbar Color: <input id="taskbar-color-input" type="color" /></label><label>Taskbar Opacity: <input id="taskbar-opacity-input" type="range" min="0.3" max="1" step="0.1" style="width: 100%;" /></label><label>Icon Style: <select id="icon-style-select"><option value="square">Square</option><option value="circle">Circle</option><option value="rounded">Rounded</option></select></label><label style="cursor:pointer;"><input type="checkbox" id="custom-icons-toggle" /> Customize App Icons</label><div id="icon-customizer" style="display:none; border:1px solid #ddd; border-radius:6px; padding:10px; margin-top:10px; max-height:200px; overflow-y:auto;"><div style="font-size:13px; font-weight:bold; margin-bottom:8px;">Click an app to customize its icon URL:</div><div id="app-icons-list"></div></div><div style="margin-top:10px; display:flex; gap:8px"><button id="save-settings">Save</button><button id="reset-settings">Reset to Default</button></div></div></div><div class="resizer" aria-hidden="true"></div>`;
                document.getElementById('windows').appendChild(win);
                win.style.zIndex = ++topZ;
                // position
                const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
                const vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);
                const w = 600, h = 500; win.style.position='absolute'; win.style.width = w+'px'; win.style.height = h+'px'; win.style.left = Math.max(10, Math.floor((vw - w)/2)) + 'px'; win.style.top = Math.max(10, Math.floor((vh - h)/2)) + 'px';
                // wire close/minimize/fullscreen
                win.querySelector('.close').addEventListener('click', ()=> win.remove());
                win.querySelector('.minimize').addEventListener('click', ()=> win.style.display='none');
                win.querySelector('.fullscreen').addEventListener('click', ()=>{
                    win.classList.toggle('fullscreen');
                    if(win.classList.contains('fullscreen')){
                        win.style.position = 'fixed';
                        win.style.left = '0';
                        win.style.top = '0';
                        win.style.width = '100%';
                        win.style.height = '100%';
                        win.style.zIndex = ++topZ;
                        win.querySelector('.resizer').style.display = 'none';
                    } else {
                        win.style.position = 'absolute';
                        const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
                        const vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);
                        const w = 600, h = 500;
                        win.style.width = w+'px';
                        win.style.height = h+'px';
                        win.style.left = Math.max(10, Math.floor((vw - w)/2)) + 'px';
                        win.style.top = Math.max(10, Math.floor((vh - h)/2)) + 'px';
                        win.querySelector('.resizer').style.display = 'block';
                    }
                });
                // basic drag
                (function(){ const bar = win.querySelector('.titlebar'); let pid=null, sx=0, sy=0, ox=0, oy=0; function mv(e){ if(e.pointerId!==pid) return; win.style.left = (ox + e.clientX - sx) + 'px'; win.style.top = (oy + e.clientY - sy) + 'px'; } function up(e){ if(e.pointerId!==pid) return; try{ bar.releasePointerCapture(pid);}catch(err){} pid=null; document.removeEventListener('pointermove', mv); document.removeEventListener('pointerup', up); } bar.addEventListener('pointerdown', (e)=>{ if(e.target.closest('button') || e.target.closest('.title-actions')) return; pid=e.pointerId; bar.setPointerCapture(pid); sx=e.clientX; sy=e.clientY; const r=win.getBoundingClientRect(); ox=r.left; oy=r.top; document.addEventListener('pointermove', mv); document.addEventListener('pointerup', up); }); })();
                // resizer (allow settings window to be resized)
                (function(){ const resizer = win.querySelector('.resizer'); if(!resizer) return; let rid=null, sx=0, sy=0, sw=0, sh=0; function mv(e){ if(e.pointerId!==rid) return; win.style.width = Math.max(300, sw + e.clientX - sx) + 'px'; win.style.height = Math.max(200, sh + e.clientY - sy) + 'px'; } function up(e){ if(e.pointerId!==rid) return; try{ resizer.releasePointerCapture(rid);}catch(err){} rid=null; document.removeEventListener('pointermove', mv); document.removeEventListener('pointerup', up); } resizer.addEventListener('pointerdown', (e)=>{ rid=e.pointerId; resizer.setPointerCapture(rid); sx=e.clientX; sy=e.clientY; const r=win.getBoundingClientRect(); sw=r.width; sh=r.height; document.addEventListener('pointermove', mv); document.addEventListener('pointerup', up); }); })();
                // wire save button
                const saveBtn = win.querySelector('#save-settings');
                const fontSelect = win.querySelector('#font-select');
                const wallpaperSelect = win.querySelector('#wallpaper-select');
                const wallpaperInput = win.querySelector('#wallpaper-input');
                const customStackInput = win.querySelector('#custom-stack-input');
                const previewArea = win.querySelector('#settings-preview');
                const resetBtn = win.querySelector('#reset-settings');
                const taskbarColorInput = win.querySelector('#taskbar-color-input');
                const taskbarOpacityInput = win.querySelector('#taskbar-opacity-input');
                const iconStyleSelect = win.querySelector('#icon-style-select');
                const cur = loadSettings();
                if(cur.fontFamily) {
                    fontSelect.value = cur.fontFamily;
                } else {
                    // try to prefill from the active CSS variable (if set)
                    const comp = getComputedStyle(document.documentElement).getPropertyValue('--desktop-font').trim();
                    if(comp){
                        const match = Array.from(fontSelect.options).find(o=>o.value.trim()===comp);
                        if(match) fontSelect.value = match.value;
                    }
                }
                if(cur.wallpaper) {
                    // check if it's one of the preset options
                    const match = Array.from(wallpaperSelect.options).find(o=>o.value === cur.wallpaper);
                    if(match) {
                        wallpaperSelect.value = cur.wallpaper;
                    } else {
                        wallpaperSelect.value = 'custom';
                        wallpaperInput.value = cur.wallpaper;
                        wallpaperInput.style.display = 'block';
                    }
                }
                if(cur.customStack) customStackInput.value = cur.customStack;
                if(cur.taskbarColor) taskbarColorInput.value = cur.taskbarColor;
                else taskbarColorInput.value = '#0b2b4a';
                if(cur.taskbarOpacity) taskbarOpacityInput.value = cur.taskbarOpacity;
                else taskbarOpacityInput.value = '1';
                if(cur.iconStyle) iconStyleSelect.value = cur.iconStyle;

                // Handle wallpaper dropdown
                wallpaperSelect.addEventListener('change', ()=>{
                    if(wallpaperSelect.value === 'custom') {
                        wallpaperInput.style.display = 'block';
                    } else {
                        wallpaperInput.style.display = 'none';
                        // preview the selected wallpaper
                        document.getElementById('desktop').style.backgroundImage = `url('${wallpaperSelect.value}')`;
                    }
                });

                // preview custom stack live
                customStackInput.addEventListener('input', ()=>{
                    const val = customStackInput.value.trim();
                    if(val){
                        previewArea.style.fontFamily = val;
                    } else {
                        previewArea.style.fontFamily = getComputedStyle(document.documentElement).getPropertyValue('--desktop-font');
                    }
                });

                // Live preview taskbar color
                function updateTaskbarColor(){
                    const taskbar = document.getElementById('taskbar');
                    if(!taskbar) return;
                    const color = taskbarColorInput.value;
                    const opacity = parseFloat(taskbarOpacityInput.value);
                    // convert hex to rgba
                    const r = parseInt(color.slice(1, 3), 16);
                    const g = parseInt(color.slice(3, 5), 16);
                    const b = parseInt(color.slice(5, 7), 16);
                    taskbar.style.setProperty('background', `rgba(${r}, ${g}, ${b}, ${opacity})`, 'important');
                }
                taskbarColorInput.addEventListener('input', updateTaskbarColor);

                // Live preview taskbar opacity
                taskbarOpacityInput.addEventListener('input', updateTaskbarColor);

                // Live preview icon style
                iconStyleSelect.addEventListener('change', ()=>{
                    const style = iconStyleSelect.value;
                    const taskbar = document.getElementById('taskbar');
                    if(taskbar) {
                        taskbar.classList.remove('icon-square', 'icon-circle', 'icon-rounded');
                        if(style !== 'square') {
                            taskbar.classList.add('icon-' + style);
                        }
                    }
                });

                // Handle app icon customization
                const customIconsToggle = win.querySelector('#custom-icons-toggle');
                const iconCustomizer = win.querySelector('#icon-customizer');
                const appIconsList = win.querySelector('#app-icons-list');
                
                // Default icons mapping for restoration
                const defaultIcons = {
                    'settings': { type: 'img', src: 'https://images.vexels.com/media/users/3/143276/isolated/preview/98336182a8a47d620c44bc80a1a4abdc-cog-wheel.png' },
                    'portfolio': { type: 'glyph', class: 'glyph folder green' },
                    'images': { type: 'img', src: 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRLvwmXlstUSTVmA0C2KWphEIlqJr1mk3ySrQ&s' },
                    'drawing': { type: 'img', src: 'assets/drawing-icon.svg' },
                    'music': { type: 'img', src: 'assets/musicnote.png' },
                    'studies': { type: 'img', src: 'assets/iconbook.png' },
                    'calculator': { type: 'glyph', class: 'glyph folder indigo' }
                };
                
                const appList = [
                    { id: 'settings', label: 'Settings' },
                    { id: 'portfolio', label: 'Portfolio' },
                    { id: 'images', label: 'Images' },
                    { id: 'drawing', label: 'Drawing' },
                    { id: 'music', label: 'Music' },
                    { id: 'studies', label: 'Studies' },
                    { id: 'calculator', label: 'Calculator' }
                ];
                
                // Build app icons list UI
                appIconsList.innerHTML = appList.map(app => `
                    <div style="display:flex; gap:6px; align-items:center; padding:6px; border-bottom:1px solid #eee;">
                        <span style="min-width:80px; font-weight:500;">${app.label}:</span>
                        <input type="text" class="app-icon-input" data-app="${app.id}" placeholder="URL or emoji" style="flex:1; padding:4px 6px; border:1px solid #ccc; border-radius:3px;" />
                        <button class="clear-icon-btn" data-app="${app.id}" style="padding:4px 8px; font-size:12px;">Clear</button>
                    </div>
                `).join('');
                
                // Load current custom icons
                if(cur.appIcons) {
                    appList.forEach(app => {
                        const input = appIconsList.querySelector(`input[data-app="${app.id}"]`);
                        if(input && cur.appIcons[app.id]) {
                            input.value = cur.appIcons[app.id];
                        }
                    });
                }
                
                // Show/hide icon customizer
                customIconsToggle.addEventListener('change', ()=>{
                    if(customIconsToggle.checked) {
                        iconCustomizer.style.display = 'block';
                    } else {
                        iconCustomizer.style.display = 'none';
                    }
                });
                
                // Clear individual app icons
                appIconsList.addEventListener('click', (e)=>{
                    if(e.target.classList.contains('clear-icon-btn')) {
                        const appId = e.target.dataset.app;
                        appIconsList.querySelector(`input[data-app="${appId}"]`).value = '';
                        
                        // Restore original icon immediately
                        const iconMap = {
                            'settings': '[data-href="settings"]',
                            'portfolio': '[data-href="portfolio.html"]',
                            'images': '[data-href="images.html"]',
                            'drawing': '[data-href="newer-mini-projects/mini-projects/drawing-app/drawing.html"]',
                            'music': '[data-href="newer-mini-projects/music-app/index.html"]',
                            'studies': '[data-href="studies.html"]',
                            'calculator': '[data-href="calculator.html"]'
                        };
                        
                        const selector = iconMap[appId];
                        if(selector) {
                            const iconEl = document.querySelector('.icon' + selector);
                            if(iconEl && defaultIcons[appId]) {
                                const defaultIcon = defaultIcons[appId];
                                const existingImg = iconEl.querySelector('.app-icon');
                                const existingGlyph = iconEl.querySelector('.glyph');
                                const customIcons = iconEl.querySelectorAll('.app-icon-custom');
                                
                                // Remove all current icon elements
                                if(existingImg) existingImg.remove();
                                if(existingGlyph) existingGlyph.remove();
                                customIcons.forEach(el => el.remove());
                                
                                // Restore original icon
                                if(defaultIcon.type === 'img') {
                                    const img = document.createElement('img');
                                    img.className = 'app-icon';
                                    img.src = defaultIcon.src;
                                    img.alt = 'App Icon';
                                    iconEl.insertBefore(img, iconEl.querySelector('span'));
                                } else if(defaultIcon.type === 'glyph') {
                                    const glyph = document.createElement('span');
                                    glyph.className = defaultIcon.class;
                                    iconEl.insertBefore(glyph, iconEl.querySelector('span'));
                                }
                            }
                        }
                    }
                });

                // Reset to defaults
                resetBtn.addEventListener('click', ()=>{
                    if(!confirm('Reset settings to defaults?')) return;
                    localStorage.removeItem('desktopSettings');
                    // remove injected google font
                    const prev = document.querySelector('link[data-google-font]'); if(prev) prev.remove();
                    // reset CSS var and body style
                    document.documentElement.style.removeProperty('--desktop-font');
                    document.body.style.fontFamily = '';
                    // reset wallpaper
                    document.getElementById('desktop').style.backgroundImage = "url('assets/bliss.jpg')";
                    // reset taskbar styles
                    const taskbar = document.getElementById('taskbar');
                    if(taskbar) {
                        taskbar.style.backgroundColor = '';
                        taskbar.style.opacity = '';
                        taskbar.classList.remove('icon-square', 'icon-circle', 'icon-rounded');
                    }
                    alert('Settings reset. Reloading page to apply defaults.');
                    location.reload();
                });
                saveBtn.addEventListener('click', ()=>{ 
                    const wallpaperValue = wallpaperSelect.value === 'custom' ? wallpaperInput.value : wallpaperSelect.value;
                    // Collect app icons
                    const appIcons = {};
                    appList.forEach(app => {
                        const input = appIconsList.querySelector(`input[data-app="${app.id}"]`);
                        if(input && input.value.trim()) {
                            appIcons[app.id] = input.value.trim();
                        }
                    });
                    const settings = { 
                        fontFamily: customStackInput.value.trim() || fontSelect.value, 
                        wallpaper: wallpaperValue || 'assets/bliss.jpg', 
                        customStack: customStackInput.value.trim() || undefined, 
                        taskbarColor: taskbarColorInput.value, 
                        taskbarOpacity: taskbarOpacityInput.value, 
                        iconStyle: iconStyleSelect.value,
                        appIcons: Object.keys(appIcons).length > 0 ? appIcons : undefined
                    }; 
                    saveSettings(settings); 
                    applySettings(settings); 
                    previewArea.style.fontFamily = settings.fontFamily; 
                    alert('Settings saved'); 
                });
                setTimeout(()=> win.classList.remove('opening'), 260);
                return win;
            }
            if(settingsIcon){ settingsIcon.addEventListener('dblclick', ()=> createSettingsWindow()); settingsIcon.addEventListener('keydown', (e)=>{ if(e.key==='Enter') createSettingsWindow(); }); }
            // apply settings on load
            applySettings(loadSettings());

            // Start menu toggle and images open handler
            const start = document.getElementById('start-button');
            const startMenu = document.getElementById('start-menu');
            start.addEventListener('click', ()=>{ startMenu.hidden = !startMenu.hidden; });

            // Handle clicks inside the Start menu. Prevent full-page navigation and open apps in windows instead.
            startMenu.addEventListener('click', (e)=>{
                const a = e.target.closest('a');
                if(!a) return;
                e.preventDefault();
                const href = a.getAttribute('href');
                // settings is a special in-page app
                if(a.id === 'start-settings'){
                    createSettingsWindow();
                    startMenu.hidden = true;
                    return;
                }
                // home: just close the menu (we're already on the desktop)
                if(href === 'index.html'){
                    startMenu.hidden = true;
                    return;
                }
                // open other apps in a window (iframe)
                if(href){
                    createWindow(a.textContent.trim(), href);
                    startMenu.hidden = true;
                }
            });

            // Clock
            const clock = document.getElementById('clock');
            function updateClock(){ const now = new Date(); clock.textContent = now.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'}); }
            updateClock(); setInterval(updateClock, 1000);

            // Secret: make clock a physical button that requires 3 clicks to open secret.html
            (function(){
                let clicks = 0; let timer = null;
                function reset(){ clicks = 0; clock.classList.remove('pressed'); if(timer){ clearTimeout(timer); timer = null; } }
                clock.style.cursor = 'pointer';
                clock.addEventListener('click', ()=>{
                    clicks++;
                    clock.classList.add('pressed');
                    if(timer) clearTimeout(timer);
                    timer = setTimeout(()=> reset(), 1200);
                    if(clicks >= 3){ reset(); openSecretModal(); }
                });
            })();

            // listen for confirmations from the iframe (iframe is authoritative). Do NOT cache unlocked state here.
            window.addEventListener('message', (ev)=>{
                try{
                    if(ev.data && ev.data.type === 'secret-unlocked'){
                        // iframe confirmed the user unlocked the secret; we do not set session flags here to avoid bypass.
                        // Optionally show a brief visual confirmation in the parent UI (left as an exercise).
                    }
                }catch(e){}
            });

            // Remove the old dblclick-based password entry; we require 3 clicks now.

            // openSecretModal: reusable password modal + unlock-mode select
            function openSecretModal(){
                // quick path removed: always show the password modal so the iframe remains authoritative for unlocking
                // if a modal already exists, bring it to front
                    if(document.getElementById('secret-pw-modal')){
                        const m = document.getElementById('secret-pw-modal'); m.style.zIndex = ++topZ; return;
                    }

                    // enforce cooldown: if lockUntil exists and is in the future, show the lock modal instead of allowing attempts
                    function getLockUntil(){ try{ return parseInt(sessionStorage.getItem('secretLockUntil')||'0',10)||0; }catch(e){ return 0; } }
                    if(getLockUntil() > Date.now()){ showLockModal(); return; }

                    const MAX_ATTEMPTS = 3;

                const modal = document.createElement('div');
                modal.id = 'secret-pw-modal';
                modal.style.position = 'fixed';
                modal.style.left = '0'; modal.style.top = '0'; modal.style.right = '0'; modal.style.bottom = '0';
                modal.style.display = 'flex'; modal.style.alignItems = 'center'; modal.style.justifyContent = 'center';
                modal.style.background = 'rgba(0,0,0,0.45)'; modal.style.zIndex = ++topZ;

                const box = document.createElement('div');
                box.style.width = '360px'; box.style.padding = '16px'; box.style.borderRadius = '8px'; box.style.background = '#fff'; box.style.color = '#111'; box.style.boxShadow = '0 8px 30px rgba(0,0,0,0.4)';
                // simplified modal: proxy-only (parent forwards password to iframe); no explanation text
                box.innerHTML = `<div style="font-weight:700; margin-bottom:8px">Enter password</div><div style="margin-bottom:8px; font-size:13px; color:#444">This area is protected. You have ${MAX_ATTEMPTS} attempts.</div><input id="secret-pw-input" type="password" style="width:100%; padding:8px; margin-bottom:8px; box-sizing:border-box; border:1px solid #ccc; border-radius:4px" /><label style="display:flex; gap:8px; align-items:center; font-size:13px; margin-bottom:8px"><input id="secret-show" type="checkbox" style="width:16px; height:16px;"> Show password</label><div style="display:flex; gap:8px; justify-content:flex-end"><button id="secret-cancel" style="padding:6px 10px;">Cancel</button><button id="secret-submit" style="padding:6px 10px; background:#2563eb; color:#fff; border:none; border-radius:4px">Unlock</button></div><div id="secret-pw-feedback" style="margin-top:8px; font-size:13px; color:#b91c1c; display:none"></div>`;

                modal.appendChild(box);
                document.body.appendChild(modal);

                const input = box.querySelector('#secret-pw-input');
                const submit = box.querySelector('#secret-submit');
                const cancel = box.querySelector('#secret-cancel');
                const feedback = box.querySelector('#secret-pw-feedback');

                function closeModal(){ try{ modal.remove(); }catch(e){} }

                // attempt helpers stored in sessionStorage so lockout survives modal closes
                function getAttempts(){ try{ return parseInt(sessionStorage.getItem('secretAttempts')||'0',10) || 0; }catch(e){ return 0; } }
                function setAttempts(n){ try{ sessionStorage.setItem('secretAttempts', String(n)); }catch(e){} }
                function clearAttempts(){ try{ sessionStorage.removeItem('secretAttempts'); }catch(e){} }

                function fail(msg){ const prev = getAttempts(); const attempts = prev + 1; setAttempts(attempts); const remaining = Math.max(0, MAX_ATTEMPTS - attempts); feedback.style.display='block'; feedback.textContent = msg || 'Incorrect password'; if(remaining > 0) feedback.textContent += ` — ${remaining} attempt${remaining>1? 's':''} left`; if(attempts >= MAX_ATTEMPTS){ feedback.textContent = 'Too many failed attempts.'; submit.disabled = true; input.disabled = true; const until = Date.now() + 60*1000; sessionStorage.setItem('secretLockUntil', String(until)); setTimeout(closeModal, 1200); showLockModal(); } }

                // normalize input to avoid invisible characters or accidental extra spaces
                function normalizePw(s){ try{ s = (s || '').normalize('NFKC'); }catch(e){} s = s.replace(/\u200B/g,''); // zero-width
                    s = s.replace(/\s+/g,' ').trim(); return s; }

                function getLockUntil(){ try{ return parseInt(sessionStorage.getItem('secretLockUntil')||'0',10)||0; }catch(e){ return 0; } }

                function showLockModal(){
                    const until = getLockUntil();
                    if(until <= Date.now()){
                        // cooldown already passed
                        sessionStorage.removeItem('secretAttempts');
                        sessionStorage.removeItem('secretLockUntil');
                        try{ delete document.documentElement.dataset.secretLocked; }catch(e){}
                        return;
                    }
                    const lm = document.createElement('div');
                    lm.id = 'secret-lock-modal';
                    lm.style.position = 'fixed'; lm.style.left = '0'; lm.style.top = '0'; lm.style.right = '0'; lm.style.bottom = '0';
                    lm.style.display = 'flex'; lm.style.alignItems = 'center'; lm.style.justifyContent = 'center';
                    lm.style.background = 'rgba(0,0,0,0.45)'; lm.style.zIndex = ++topZ;
                    const inner = document.createElement('div');
                    inner.style.width = '320px'; inner.style.padding = '16px'; inner.style.borderRadius = '8px';
                    inner.style.background = '#fff'; inner.style.color = '#111'; inner.style.boxShadow = '0 8px 30px rgba(0,0,0,0.4)';
                    inner.innerHTML = `<div style="font-weight:700; margin-bottom:8px">Too many attempts</div><div id='lock-msg' style='font-size:13px; color:#444; margin-bottom:8px'>Please wait...</div><div style='text-align:right'><button id='lock-close' style='padding:6px 8px'>Close</button></div>`;
                    lm.appendChild(inner);
                    document.body.appendChild(lm);

                    // set a document-level flag so the parent knows the secret is locked
                    try{ document.documentElement.dataset.secretLocked = '1'; }catch(e){}

                    const msg = inner.querySelector('#lock-msg');
                    const closeBtn = inner.querySelector('#lock-close');
                    let interval = null;

                    function update(){
                        const rem = Math.max(0, getLockUntil() - Date.now());
                        if(rem <= 0){
                            try{ lm.remove(); }catch(e){}
                            try{ delete document.documentElement.dataset.secretLocked; }catch(e){}
                            sessionStorage.removeItem('secretAttempts');
                            sessionStorage.removeItem('secretLockUntil');
                            clearInterval(interval);
                            return;
                        }
                        const s = Math.ceil(rem/1000);
                        msg.textContent = `Try again in ${s} second${s!==1?'s':''}.`;
                    }
                    update();
                    interval = setInterval(update, 1000);

                    // Close button only dismisses the UI; it does NOT clear attempts or lift the lock.
                    closeBtn.addEventListener('click', ()=>{ try{ lm.remove(); }catch(e){} clearInterval(interval); });
                }

                function trySubmit(){ const raw = input.value || ''; const val = normalizePw(raw); const allowed = ['M30W'];
                    // proxy-only: parent forwards the typed password to the iframe and iframe must confirm
                    if(allowed.includes(val)){
                        clearAttempts(); sessionStorage.removeItem('secretLockUntil'); closeModal(); const winEl = createWindow('Secret', 'newer-mini-projects/secret/secret.html', '#111827');
                        try{ const iframe = winEl.querySelector('iframe'); if(iframe){ iframe.addEventListener('load', ()=>{ try{ iframe.contentWindow.postMessage({ type: 'try-unlock', password: val }, location.origin); }catch(e){} }); }
                        }catch(e){}
                    } else {
                        fail('Incorrect password'); input.value=''; input.focus();
                    }
                }

                // show password toggle
                const showToggle = box.querySelector('#secret-show'); if(showToggle){ showToggle.addEventListener('change', (e)=>{ input.type = showToggle.checked ? 'text' : 'password'; }); }

                submit.addEventListener('click', trySubmit);
                input.addEventListener('keydown', (e)=>{ if(e.key === 'Enter') trySubmit(); if(e.key === 'Escape') { closeModal(); } });
                cancel.addEventListener('click', ()=> closeModal());
                // ensure the input can be typed into (delay a tick to allow focus)
                setTimeout(()=>{ try{ input.focus(); input.select(); }catch(e){} }, 50);
            }
        })();
        </script>
    </body>
</html>