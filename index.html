<!DOCTYPE HTML>
<html>
    <head>
        <title>My First Website</title>
        <link rel="stylesheet" href="style.css">
    </head>

    <body>
        <div id="desktop">
            <div id="icons">
                <div class="icon" data-href="settings" data-color="#3b82f6" tabindex="0">
                    <img class="app-icon" src="https://images.vexels.com/media/users/3/143276/isolated/preview/98336182a8a47d620c44bc80a1a4abdc-cog-wheel.png" alt="Settings" />
                    <span>Settings</span>
                </div>
                <div class="icon" data-href="portfolio.html" data-color="#10b981" tabindex="0">
                    <span class="glyph folder green"></span>
                    <span>Portfolio</span>
                </div>
                <div class="icon" data-href="images.html" data-color="#ef4444" tabindex="0">
                    <img class="app-icon" src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRLvwmXlstUSTVmA0C2KWphEIlqJr1mk3ySrQ&s" alt="Images" />
                    <span>Images</span>
                </div>
                <div class="icon" data-href="newer-mini-projects/mini-projects/drawing-app/drawing.html" data-color="#8b5cf6" tabindex="0">
                    <img class="app-icon" src="assets/drawing-icon.svg" alt="Drawing" />
                    <span>Drawing</span>
                </div>
                <div class="icon" data-href="newer-mini-projects/music-app/index.html" data-color="#ef4444" tabindex="0">
                    <img class="app-icon" src="assets/musicnote.png" alt="Music" />
                    <span>Music</span>
                </div>
                <!-- Secret icon removed per request -->
            </div>

            <div id="taskbar">
                <button id="start-button">Start</button>
                <div id="taskbar-icons"></div>
                <div id="tray">
                    <div id="clock"></div>
                </div>
            </div>

            <div id="windows"></div>

            <div id="start-menu" hidden>
                <div class="start-header">Start Menu</div>
                <ul>
                    <li><a href="index.html">Home</a></li>
                    <li><a href="#" id="start-settings">Settings</a></li>
                    <li><a href="newer-mini-projects/mini-projects/drawing-app/drawing.html">Drawing</a></li>
                    <li><a href="newer-mini-projects/music-app/index.html">Music</a></li>
                </ul>
            </div>
        </div>

        <script>
        // Desktop icon interactions
            (function(){
            const icons = document.querySelectorAll('.icon');
            const iconsWrap = document.getElementById('icons');

            // make icons container positioning context for absolute-placed icons
            if(getComputedStyle(iconsWrap).position === 'static') iconsWrap.style.position = 'relative';

            // load saved icon positions from localStorage
            function loadIconPositions(){
                try{
                    const raw = localStorage.getItem('desktopIconPositions');
                    if(!raw) return {};
                    return JSON.parse(raw);
                }catch(e){ return {}; }
            }
            function saveIconPositions(map){
                try{ localStorage.setItem('desktopIconPositions', JSON.stringify(map)); }catch(e){}
            }
            const savedPositions = loadIconPositions();
            // apply saved positions (if any)
            icons.forEach(icon=>{
                const key = icon.dataset.href || icon.textContent.trim();
                const pos = savedPositions[key];
                if(pos && typeof pos.left === 'number' && typeof pos.top === 'number'){
                    icon.style.position = 'absolute';
                    icon.style.left = pos.left + 'px';
                    icon.style.top = pos.top + 'px';
                }
            });
            const windows = document.getElementById('windows');
            const taskbarIcons = document.getElementById('taskbar-icons');
            let topZ = 1000;

            function createWindow(title, href, color = '#6b7280'){
                const win = document.createElement('div');
                win.className = 'window opening';
                // build window titlebar and controls (no Home button)
                win.innerHTML = `<div class="titlebar"><span class="title">${title}</span><div class="title-actions"><button class="minimize">–</button><button class="fullscreen" aria-pressed="false">▢</button><button class="close">✕</button></div></div><div class="content"><div class="iframe-wrap"><iframe src="${href}" frameborder="0"></iframe></div></div><div class="resizer" aria-hidden="true"></div>`;
                windows.appendChild(win);
                win.style.zIndex = ++topZ;

                // taskbar button
                const taskBtn = document.createElement('button');
                taskBtn.className = 'task-btn';
                taskBtn.innerHTML = `<span class="task-icon" style="background:${color}; box-shadow: inset 0 -2px rgba(0,0,0,0.12);"></span>`;
                taskBtn.title = title;
                taskbarIcons.appendChild(taskBtn);

                const close = win.querySelector('.close');
                close.addEventListener('click', ()=>{ try{ win.remove(); }catch(e){} try{ taskBtn.remove(); }catch(e){} });

                // cleanup embedded page UI when iframe loads
                const iframe = win.querySelector('iframe');
                iframe.addEventListener('load', ()=>{
                    try{
                        const idoc = iframe.contentDocument || iframe.contentWindow.document;
                        // hide common desktop elements inside embedded pages
                        const selectors = ['header.section','nav','#taskbar','#start-menu','#icons','footer','.section .nav'];
                        selectors.forEach(sel=>{
                            const el = idoc.querySelector(sel);
                            if(el) el.style.display = 'none';
                        });
                        // remove body margins to reduce whitespace
                        if(idoc.body) idoc.body.style.margin = '0';
                        // also try to reduce padding on first .section if present
                        const firstSection = idoc.querySelector('.section');
                        if(firstSection) { firstSection.style.paddingTop = '6px'; firstSection.style.paddingBottom = '6px'; }
                    }catch(e){}
                });

                // center window
                const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
                const vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);
                // default window size; some apps (music) prefer a wider layout
                let initW = 640, initH = 420;
                try{
                    // if opening the music app, use a larger default size
                    if(String(href).includes('newer-mini-projects/music-app')){ initW = 900; initH = 520; }
                }catch(e){}
                win.style.position='absolute'; win.style.width = initW + 'px'; win.style.height = initH + 'px'; win.style.left = Math.max(10, Math.floor((vw - initW)/2)) + 'px'; win.style.top = Math.max(10, Math.floor((vh - initH)/2)) + 'px';

                // bring to front on pointerdown
                win.addEventListener('pointerdown', ()=> win.style.zIndex = ++topZ);

                // draggable
                (function(){
                    const bar = win.querySelector('.titlebar');
                    let pid=null, sx=0, sy=0, ox=0, oy=0;
                    function mv(e){ if(e.pointerId!==pid) return; win.style.left = (ox + e.clientX - sx) + 'px'; win.style.top = (oy + e.clientY - sy) + 'px'; }
                    function up(e){ if(e.pointerId!==pid) return; try{ bar.releasePointerCapture(pid);}catch(err){} pid=null; document.removeEventListener('pointermove', mv); document.removeEventListener('pointerup', up); }
                    bar.addEventListener('pointerdown', (e)=>{
                        // don't start drag when clicking controls
                        if(e.target.closest('button') || e.target.closest('.title-actions')) return;
                        pid=e.pointerId; bar.setPointerCapture(pid); sx=e.clientX; sy=e.clientY; const r=win.getBoundingClientRect(); ox=r.left; oy=r.top; document.addEventListener('pointermove', mv); document.addEventListener('pointerup', up);
                    });
                    // double-click titlebar to toggle fullscreen
                    bar.addEventListener('dblclick', ()=>{ const fs = win.querySelector('.fullscreen'); if(fs) fs.click(); });
                })();

                // resizer
                (function(){ const resizer = win.querySelector('.resizer'); let rid=null, sx=0, sy=0, sw=0, sh=0; function mv(e){ if(e.pointerId!==rid) return; win.style.width = Math.max(300, sw + e.clientX - sx) + 'px'; win.style.height = Math.max(200, sh + e.clientY - sy) + 'px'; } function up(e){ if(e.pointerId!==rid) return; try{ resizer.releasePointerCapture(rid);}catch(err){} rid=null; document.removeEventListener('pointermove', mv); document.removeEventListener('pointerup', up); } resizer.addEventListener('pointerdown', (e)=>{ rid=e.pointerId; resizer.setPointerCapture(rid); sx=e.clientX; sy=e.clientY; const r=win.getBoundingClientRect(); sw=r.width; sh=r.height; document.addEventListener('pointermove', mv); document.addEventListener('pointerup', up); }); })();

                                // minimize
                                const minBtn = win.querySelector('.minimize'); minBtn.addEventListener('click', ()=>{ win.style.display='none'; taskBtn.classList.add('minimized'); });
                                // fullscreen
                                const fsBtn = win.querySelector('.fullscreen');
                                let maximized = false; let prevRect = null;
                                function toggleFullscreen(){
                                    if(!maximized){
                                        const rect = win.getBoundingClientRect();
                                        prevRect = {left: rect.left, top: rect.top, width: rect.width, height: rect.height};
                                        // make truly fullscreen within viewport
                                        win.classList.add('fullscreen');
                                        maximized = true; fsBtn.setAttribute('aria-pressed','true');
                                    } else {
                                        if(prevRect){ win.style.position='absolute'; win.style.left=prevRect.left+'px'; win.style.top=prevRect.top+'px'; win.style.width=prevRect.width+'px'; win.style.height=prevRect.height+'px'; }
                                        win.classList.remove('fullscreen');
                                        maximized=false; fsBtn.setAttribute('aria-pressed','false');
                                    }
                                    win.style.zIndex = ++topZ;
                                }
                                fsBtn.addEventListener('click', toggleFullscreen);
                taskBtn.addEventListener('click', ()=>{
                    // if minimized, restore and focus
                    if(win.style.display==='none' || win.classList.contains('minimized')){
                        win.style.display='block'; taskBtn.classList.remove('minimized'); win.style.zIndex = ++topZ; win.classList.remove('minimized');
                    } else {
                        // if visible, minimize it
                        win.style.display='none'; taskBtn.classList.add('minimized'); win.classList.add('minimized');
                    }
                });

                setTimeout(()=> win.classList.remove('opening'), 260);
                return win;
            }

            icons.forEach(icon=>{
                let clickCount = 0; let clickTimer = null;
                // drag state for this icon
                let dragState = { dragging:false, moved:false, pid:null, sx:0, sy:0, startLeft:0, startTop:0 };

                // pointerdown to start Alt+drag move
                icon.addEventListener('pointerdown', (e)=>{
                    // only start move when Alt is pressed
                    if(!e.altKey) return;
                    e.preventDefault();
                    dragState.dragging = true; dragState.pid = e.pointerId; dragState.sx = e.clientX; dragState.sy = e.clientY;
                    // ensure icon is absolutely positioned relative to iconsWrap
                    const wrapRect = iconsWrap.getBoundingClientRect();
                    const iconRect = icon.getBoundingClientRect();
                    // compute left/top relative to wrap
                    const curLeft = iconRect.left - wrapRect.left + iconsWrap.scrollLeft;
                    const curTop = iconRect.top - wrapRect.top + iconsWrap.scrollTop;
                    // set absolute positioning if not already
                    if(getComputedStyle(icon).position !== 'absolute'){
                        icon.style.position = 'absolute';
                        icon.style.left = Math.round(curLeft) + 'px';
                        icon.style.top = Math.round(curTop) + 'px';
                    }
                    dragState.startLeft = parseFloat(icon.style.left) || 0; dragState.startTop = parseFloat(icon.style.top) || 0;
                    icon.setPointerCapture(dragState.pid);

                    function onMove(ev){ if(!dragState.dragging || ev.pointerId !== dragState.pid) return; const dx = ev.clientX - dragState.sx; const dy = ev.clientY - dragState.sy; const rawLeft = Math.max(0, Math.round(dragState.startLeft + dx)); const rawTop = Math.max(0, Math.round(dragState.startTop + dy)); const GRID = 16; const newLeft = Math.round(rawLeft / GRID) * GRID; const newTop = Math.round(rawTop / GRID) * GRID; icon.style.left = newLeft + 'px'; icon.style.top = newTop + 'px'; dragState.moved = true; }
                    function onUp(ev){ if(ev.pointerId !== dragState.pid) return; try{ icon.releasePointerCapture(dragState.pid);}catch(err){} dragState.dragging = false; dragState.pid = null; document.removeEventListener('pointermove', onMove); document.removeEventListener('pointerup', onUp);
                        // persist positions
                        const positions = loadIconPositions();
                        const key = icon.dataset.href || icon.textContent.trim();
                        positions[key] = { left: Math.round((parseFloat(icon.style.left)||0)), top: Math.round((parseFloat(icon.style.top)||0)) };
                        saveIconPositions(positions);
                        // mark moved briefly to suppress click/dblclick
                        icon.dataset.moved = '1'; setTimeout(()=>{ delete icon.dataset.moved; }, 150);
                    }

                    document.addEventListener('pointermove', onMove);
                    document.addEventListener('pointerup', onUp);
                });

                icon.addEventListener('click', (e)=>{
                    // ignore click if this icon was just moved
                    if(icon.dataset.moved) return;
                    clickCount++; if(clickCount===1){ icon.classList.toggle('selected'); clickTimer = setTimeout(()=>{ clickCount=0; }, 300); } else if(clickCount===2){ clearTimeout(clickTimer); clickCount=0; const href = icon.dataset.href; if(href){ if(href === 'settings'){ createSettingsWindow(); } else { createWindow(icon.textContent.trim(), href); } }
                    }
                });
                icon.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ const href = icon.dataset.href; if(href){ if(href === 'settings'){ createSettingsWindow(); } else { createWindow(icon.textContent.trim(), href); } } } });
            });

            // special handling for settings icon (open internal settings UI)
            const settingsIcon = document.querySelector('.icon[data-href="settings"]');

            // helper to inject Google Font stylesheet link into the page (idempotent)
            function injectGoogleFont(family){
                if(!family) return;
                const fam = encodeURIComponent(family.trim().replace(/\s+/g,' '));
                const href = `https://fonts.googleapis.com/css2?family=${fam}:wght@400;700&display=swap`;
                const prev = document.querySelector('link[data-google-font]'); if(prev) prev.remove();
                const link = document.createElement('link'); link.rel='stylesheet'; link.href = href; link.setAttribute('data-google-font', family);
                document.head.appendChild(link);
            }

            function applySettings(settings){
                if(!settings) return;
                if(settings.googleFont) {
                    try{ injectGoogleFont(settings.googleFont); }catch(e){}
                }
                if(settings.fontFamily){
                    // set CSS variable for themes
                    document.documentElement.style.setProperty('--desktop-font', settings.fontFamily);
                    // immediate fallback for older CSS engines: set body font directly
                    try{ document.body.style.fontFamily = settings.fontFamily; }catch(e){}
                }
                if(settings.wallpaper){ document.getElementById('desktop').style.backgroundImage = `url('${settings.wallpaper}')`; }
            }
            function saveSettings(settings){ localStorage.setItem('desktopSettings', JSON.stringify(settings)); applySettings(settings); }
            function loadSettings(){ try{ return JSON.parse(localStorage.getItem('desktopSettings')||'{}'); }catch(e){ return {}; } }
            function createSettingsWindow(){
                // build a simple in-page settings window (not iframe)
                const existing = document.querySelector('.window[data-settings]'); if(existing){ existing.style.zIndex = ++topZ; return existing; }
                const win = document.createElement('div'); win.className = 'window opening'; win.setAttribute('data-settings','true');
                win.innerHTML = `<div class="titlebar"><span class="title">Settings</span><div class="title-actions"><button class="minimize">–</button><button class="close">✕</button></div></div><div class="content"><div class="settings-form"><label>Font: <select id="font-select"><option value="'Segoe UI', Tahoma, Geneva, Verdana, sans-serif">Default</option><option value="Arial, Helvetica, sans-serif">Arial</option><option value="'Courier New', monospace">Monospace</option><option value="Georgia, serif">Serif</option><option value="'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial">Inter</option><option value="'Poppins', system-ui, -apple-system, Roboto, 'Helvetica Neue', Arial">Poppins</option><option value="'Lato', system-ui, Roboto, 'Helvetica Neue', Arial">Lato</option><option value="'Montserrat', system-ui, Roboto, 'Helvetica Neue', Arial">Montserrat</option></select></label><label>Or Google Font (family name): <input id="google-font-input" placeholder="e.g. Roboto" /></label><div style="display:flex;gap:8px"><button id="preview-google">Preview</button><button id="load-google">Load & Save</button></div><label>Custom font stack (CSS): <input id="custom-stack-input" placeholder="e.g. 'Segoe UI', system-ui, sans-serif" /></label><div id="settings-preview" class="settings-preview">The quick brown fox jumps over the lazy dog — Preview text</div><label>Wallpaper URL: <input id="wallpaper-input" placeholder="assets/bliss.jpg"></label><div style="margin-top:10px; display:flex; gap:8px"><button id="save-settings">Save</button><button id="reset-settings">Reset to Default</button></div></div></div><div class="resizer" aria-hidden="true"></div>`;
                document.getElementById('windows').appendChild(win);
                win.style.zIndex = ++topZ;
                // position
                const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
                const vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);
                const w = 420, h = 260; win.style.position='absolute'; win.style.width = w+'px'; win.style.height = h+'px'; win.style.left = Math.max(10, Math.floor((vw - w)/2)) + 'px'; win.style.top = Math.max(10, Math.floor((vh - h)/2)) + 'px';
                // wire close/minimize
                win.querySelector('.close').addEventListener('click', ()=> win.remove());
                win.querySelector('.minimize').addEventListener('click', ()=> win.style.display='none');
                // basic drag
                (function(){ const bar = win.querySelector('.titlebar'); let pid=null, sx=0, sy=0, ox=0, oy=0; function mv(e){ if(e.pointerId!==pid) return; win.style.left = (ox + e.clientX - sx) + 'px'; win.style.top = (oy + e.clientY - sy) + 'px'; } function up(e){ if(e.pointerId!==pid) return; try{ bar.releasePointerCapture(pid);}catch(err){} pid=null; document.removeEventListener('pointermove', mv); document.removeEventListener('pointerup', up); } bar.addEventListener('pointerdown', (e)=>{ if(e.target.closest('button') || e.target.closest('.title-actions')) return; pid=e.pointerId; bar.setPointerCapture(pid); sx=e.clientX; sy=e.clientY; const r=win.getBoundingClientRect(); ox=r.left; oy=r.top; document.addEventListener('pointermove', mv); document.addEventListener('pointerup', up); }); })();
                // resizer (allow settings window to be resized)
                (function(){ const resizer = win.querySelector('.resizer'); if(!resizer) return; let rid=null, sx=0, sy=0, sw=0, sh=0; function mv(e){ if(e.pointerId!==rid) return; win.style.width = Math.max(300, sw + e.clientX - sx) + 'px'; win.style.height = Math.max(200, sh + e.clientY - sy) + 'px'; } function up(e){ if(e.pointerId!==rid) return; try{ resizer.releasePointerCapture(rid);}catch(err){} rid=null; document.removeEventListener('pointermove', mv); document.removeEventListener('pointerup', up); } resizer.addEventListener('pointerdown', (e)=>{ rid=e.pointerId; resizer.setPointerCapture(rid); sx=e.clientX; sy=e.clientY; const r=win.getBoundingClientRect(); sw=r.width; sh=r.height; document.addEventListener('pointermove', mv); document.addEventListener('pointerup', up); }); })();
                // wire save button
                const saveBtn = win.querySelector('#save-settings');
                const fontSelect = win.querySelector('#font-select');
                const wallpaperInput = win.querySelector('#wallpaper-input');
                const googleInput = win.querySelector('#google-font-input');
                const previewBtn = win.querySelector('#preview-google');
                const loadGoogleBtn = win.querySelector('#load-google');
                const customStackInput = win.querySelector('#custom-stack-input');
                const previewArea = win.querySelector('#settings-preview');
                const resetBtn = win.querySelector('#reset-settings');
                const cur = loadSettings();
                if(cur.fontFamily) {
                    fontSelect.value = cur.fontFamily;
                } else {
                    // try to prefill from the active CSS variable (if set)
                    const comp = getComputedStyle(document.documentElement).getPropertyValue('--desktop-font').trim();
                    if(comp){
                        const match = Array.from(fontSelect.options).find(o=>o.value.trim()===comp);
                        if(match) fontSelect.value = match.value;
                    }
                }
                if(cur.wallpaper) wallpaperInput.value = cur.wallpaper;
                if(cur.googleFont) googleInput.value = cur.googleFont;
                if(cur.customStack) customStackInput.value = cur.customStack;

                // helper to inject google font link
                function injectGoogleFont(family){
                    if(!family) return;
                    // normalize family (e.g., 'Roboto' -> 'Roboto:400,700') ; keep simple and request regular weight
                    const fam = encodeURIComponent(family.trim().replace(/\s+/g,' '));
                    const href = `https://fonts.googleapis.com/css2?family=${fam}:wght@400;700&display=swap`;
                    // remove any previous injected link with data-google-font
                    const prev = document.querySelector('link[data-google-font]'); if(prev) prev.remove();
                    const link = document.createElement('link'); link.rel='stylesheet'; link.href = href; link.setAttribute('data-google-font', family);
                    document.head.appendChild(link);
                }

                previewBtn.addEventListener('click', ()=>{
                    const fam = googleInput.value.trim(); if(!fam) return alert('Enter a Google Font family name to preview, e.g. Roboto');
                    injectGoogleFont(fam);
                    // apply to page immediately using the family name + fallback
                    const cssVal = `'${fam}', ${fontSelect.value}`;
                    document.documentElement.style.setProperty('--desktop-font', cssVal);
                    try{ document.body.style.fontFamily = cssVal; }catch(e){}
                    previewArea.style.fontFamily = cssVal;
                });

                loadGoogleBtn.addEventListener('click', ()=>{
                    const fam = googleInput.value.trim(); if(!fam) return alert('Enter a Google Font family name to load');
                    injectGoogleFont(fam);
                    const cssVal = `'${fam}', ${fontSelect.value}`;
                    const settings = { fontFamily: cssVal, wallpaper: wallpaperInput.value || 'assets/bliss.jpg', googleFont: fam, customStack: customStackInput.value || undefined };
                    saveSettings(settings);
                    previewArea.style.fontFamily = cssVal;
                    alert('Google Font loaded and settings saved');
                });

                // preview custom stack live
                customStackInput.addEventListener('input', ()=>{
                    const val = customStackInput.value.trim();
                    if(val){
                        previewArea.style.fontFamily = val;
                    } else {
                        previewArea.style.fontFamily = getComputedStyle(document.documentElement).getPropertyValue('--desktop-font');
                    }
                });

                // Reset to defaults
                resetBtn.addEventListener('click', ()=>{
                    if(!confirm('Reset settings to defaults?')) return;
                    localStorage.removeItem('desktopSettings');
                    // remove injected google font
                    const prev = document.querySelector('link[data-google-font]'); if(prev) prev.remove();
                    // reset CSS var and body style
                    document.documentElement.style.removeProperty('--desktop-font');
                    document.body.style.fontFamily = '';
                    // reset wallpaper
                    document.getElementById('desktop').style.backgroundImage = "url('assets/bliss.jpg')";
                    alert('Settings reset. Reloading page to apply defaults.');
                    location.reload();
                });
                saveBtn.addEventListener('click', ()=>{ const settings = { fontFamily: customStackInput.value.trim() || fontSelect.value, wallpaper: wallpaperInput.value || 'assets/bliss.jpg', googleFont: googleInput.value || undefined, customStack: customStackInput.value.trim() || undefined }; saveSettings(settings); applySettings(settings); previewArea.style.fontFamily = settings.fontFamily; alert('Settings saved'); });
                setTimeout(()=> win.classList.remove('opening'), 260);
                return win;
            }
            if(settingsIcon){ settingsIcon.addEventListener('dblclick', ()=> createSettingsWindow()); settingsIcon.addEventListener('keydown', (e)=>{ if(e.key==='Enter') createSettingsWindow(); }); }
            // apply settings on load
            applySettings(loadSettings());

            // Start menu toggle and images open handler
            const start = document.getElementById('start-button');
            const startMenu = document.getElementById('start-menu');
            start.addEventListener('click', ()=>{ startMenu.hidden = !startMenu.hidden; });

            // Handle clicks inside the Start menu. Prevent full-page navigation and open apps in windows instead.
            startMenu.addEventListener('click', (e)=>{
                const a = e.target.closest('a');
                if(!a) return;
                e.preventDefault();
                const href = a.getAttribute('href');
                // settings is a special in-page app
                if(a.id === 'start-settings'){
                    createSettingsWindow();
                    startMenu.hidden = true;
                    return;
                }
                // home: just close the menu (we're already on the desktop)
                if(href === 'index.html'){
                    startMenu.hidden = true;
                    return;
                }
                // open other apps in a window (iframe)
                if(href){
                    createWindow(a.textContent.trim(), href);
                    startMenu.hidden = true;
                }
            });

            // Clock
            const clock = document.getElementById('clock');
            function updateClock(){ const now = new Date(); clock.textContent = now.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'}); }
            updateClock(); setInterval(updateClock, 1000);

            // Secret: make clock a physical button that requires 3 clicks to open secret.html
            (function(){
                let clicks = 0; let timer = null;
                function reset(){ clicks = 0; clock.classList.remove('pressed'); if(timer){ clearTimeout(timer); timer = null; } }
                clock.style.cursor = 'pointer';
                clock.addEventListener('click', ()=>{
                    clicks++;
                    clock.classList.add('pressed');
                    if(timer) clearTimeout(timer);
                    timer = setTimeout(()=> reset(), 1200);
                    if(clicks >= 3){ reset(); openSecretModal(); }
                });
            })();

            // listen for confirmations from the iframe (iframe is authoritative). Do NOT cache unlocked state here.
            window.addEventListener('message', (ev)=>{
                try{
                    if(ev.data && ev.data.type === 'secret-unlocked'){
                        // iframe confirmed the user unlocked the secret; we do not set session flags here to avoid bypass.
                        // Optionally show a brief visual confirmation in the parent UI (left as an exercise).
                    }
                }catch(e){}
            });

            // Remove the old dblclick-based password entry; we require 3 clicks now.

            // openSecretModal: reusable password modal + unlock-mode select
            function openSecretModal(){
                // quick path removed: always show the password modal so the iframe remains authoritative for unlocking
                // if a modal already exists, bring it to front
                    if(document.getElementById('secret-pw-modal')){
                        const m = document.getElementById('secret-pw-modal'); m.style.zIndex = ++topZ; return;
                    }

                    // enforce cooldown: if lockUntil exists and is in the future, show the lock modal instead of allowing attempts
                    function getLockUntil(){ try{ return parseInt(sessionStorage.getItem('secretLockUntil')||'0',10)||0; }catch(e){ return 0; } }
                    if(getLockUntil() > Date.now()){ showLockModal(); return; }

                    const MAX_ATTEMPTS = 3;

                const modal = document.createElement('div');
                modal.id = 'secret-pw-modal';
                modal.style.position = 'fixed';
                modal.style.left = '0'; modal.style.top = '0'; modal.style.right = '0'; modal.style.bottom = '0';
                modal.style.display = 'flex'; modal.style.alignItems = 'center'; modal.style.justifyContent = 'center';
                modal.style.background = 'rgba(0,0,0,0.45)'; modal.style.zIndex = ++topZ;

                const box = document.createElement('div');
                box.style.width = '360px'; box.style.padding = '16px'; box.style.borderRadius = '8px'; box.style.background = '#fff'; box.style.color = '#111'; box.style.boxShadow = '0 8px 30px rgba(0,0,0,0.4)';
                // simplified modal: proxy-only (parent forwards password to iframe); no explanation text
                box.innerHTML = `<div style="font-weight:700; margin-bottom:8px">Enter password</div><div style="margin-bottom:8px; font-size:13px; color:#444">This area is protected. You have ${MAX_ATTEMPTS} attempts.</div><input id="secret-pw-input" type="password" style="width:100%; padding:8px; margin-bottom:8px; box-sizing:border-box; border:1px solid #ccc; border-radius:4px" /><label style="display:flex; gap:8px; align-items:center; font-size:13px; margin-bottom:8px"><input id="secret-show" type="checkbox" style="width:16px; height:16px;"> Show password</label><div style="display:flex; gap:8px; justify-content:flex-end"><button id="secret-cancel" style="padding:6px 10px;">Cancel</button><button id="secret-submit" style="padding:6px 10px; background:#2563eb; color:#fff; border:none; border-radius:4px">Unlock</button></div><div id="secret-pw-feedback" style="margin-top:8px; font-size:13px; color:#b91c1c; display:none"></div>`;

                modal.appendChild(box);
                document.body.appendChild(modal);

                const input = box.querySelector('#secret-pw-input');
                const submit = box.querySelector('#secret-submit');
                const cancel = box.querySelector('#secret-cancel');
                const feedback = box.querySelector('#secret-pw-feedback');

                function closeModal(){ try{ modal.remove(); }catch(e){} }

                // attempt helpers stored in sessionStorage so lockout survives modal closes
                function getAttempts(){ try{ return parseInt(sessionStorage.getItem('secretAttempts')||'0',10) || 0; }catch(e){ return 0; } }
                function setAttempts(n){ try{ sessionStorage.setItem('secretAttempts', String(n)); }catch(e){} }
                function clearAttempts(){ try{ sessionStorage.removeItem('secretAttempts'); }catch(e){} }

                function fail(msg){ const prev = getAttempts(); const attempts = prev + 1; setAttempts(attempts); const remaining = Math.max(0, MAX_ATTEMPTS - attempts); feedback.style.display='block'; feedback.textContent = msg || 'Incorrect password'; if(remaining > 0) feedback.textContent += ` — ${remaining} attempt${remaining>1? 's':''} left`; if(attempts >= MAX_ATTEMPTS){ feedback.textContent = 'Too many failed attempts.'; submit.disabled = true; input.disabled = true; const until = Date.now() + 60*1000; sessionStorage.setItem('secretLockUntil', String(until)); setTimeout(closeModal, 1200); showLockModal(); } }

                // normalize input to avoid invisible characters or accidental extra spaces
                function normalizePw(s){ try{ s = (s || '').normalize('NFKC'); }catch(e){} s = s.replace(/\u200B/g,''); // zero-width
                    s = s.replace(/\s+/g,' ').trim(); return s; }

                function getLockUntil(){ try{ return parseInt(sessionStorage.getItem('secretLockUntil')||'0',10)||0; }catch(e){ return 0; } }

                function showLockModal(){
                    const until = getLockUntil();
                    if(until <= Date.now()){
                        // cooldown already passed
                        sessionStorage.removeItem('secretAttempts');
                        sessionStorage.removeItem('secretLockUntil');
                        try{ delete document.documentElement.dataset.secretLocked; }catch(e){}
                        return;
                    }
                    const lm = document.createElement('div');
                    lm.id = 'secret-lock-modal';
                    lm.style.position = 'fixed'; lm.style.left = '0'; lm.style.top = '0'; lm.style.right = '0'; lm.style.bottom = '0';
                    lm.style.display = 'flex'; lm.style.alignItems = 'center'; lm.style.justifyContent = 'center';
                    lm.style.background = 'rgba(0,0,0,0.45)'; lm.style.zIndex = ++topZ;
                    const inner = document.createElement('div');
                    inner.style.width = '320px'; inner.style.padding = '16px'; inner.style.borderRadius = '8px';
                    inner.style.background = '#fff'; inner.style.color = '#111'; inner.style.boxShadow = '0 8px 30px rgba(0,0,0,0.4)';
                    inner.innerHTML = `<div style="font-weight:700; margin-bottom:8px">Too many attempts</div><div id='lock-msg' style='font-size:13px; color:#444; margin-bottom:8px'>Please wait...</div><div style='text-align:right'><button id='lock-close' style='padding:6px 8px'>Close</button></div>`;
                    lm.appendChild(inner);
                    document.body.appendChild(lm);

                    // set a document-level flag so the parent knows the secret is locked
                    try{ document.documentElement.dataset.secretLocked = '1'; }catch(e){}

                    const msg = inner.querySelector('#lock-msg');
                    const closeBtn = inner.querySelector('#lock-close');
                    let interval = null;

                    function update(){
                        const rem = Math.max(0, getLockUntil() - Date.now());
                        if(rem <= 0){
                            try{ lm.remove(); }catch(e){}
                            try{ delete document.documentElement.dataset.secretLocked; }catch(e){}
                            sessionStorage.removeItem('secretAttempts');
                            sessionStorage.removeItem('secretLockUntil');
                            clearInterval(interval);
                            return;
                        }
                        const s = Math.ceil(rem/1000);
                        msg.textContent = `Try again in ${s} second${s!==1?'s':''}.`;
                    }
                    update();
                    interval = setInterval(update, 1000);

                    // Close button only dismisses the UI; it does NOT clear attempts or lift the lock.
                    closeBtn.addEventListener('click', ()=>{ try{ lm.remove(); }catch(e){} clearInterval(interval); });
                }

                function trySubmit(){ const raw = input.value || ''; const val = normalizePw(raw); const allowed = ['M30W'];
                    // proxy-only: parent forwards the typed password to the iframe and iframe must confirm
                    if(allowed.includes(val)){
                        clearAttempts(); sessionStorage.removeItem('secretLockUntil'); closeModal(); const winEl = createWindow('Secret', 'newer-mini-projects/secret/secret.html', '#111827');
                        try{ const iframe = winEl.querySelector('iframe'); if(iframe){ iframe.addEventListener('load', ()=>{ try{ iframe.contentWindow.postMessage({ type: 'try-unlock', password: val }, location.origin); }catch(e){} }); }
                        }catch(e){}
                    } else {
                        fail('Incorrect password'); input.value=''; input.focus();
                    }
                }

                // show password toggle
                const showToggle = box.querySelector('#secret-show'); if(showToggle){ showToggle.addEventListener('change', (e)=>{ input.type = showToggle.checked ? 'text' : 'password'; }); }

                submit.addEventListener('click', trySubmit);
                input.addEventListener('keydown', (e)=>{ if(e.key === 'Enter') trySubmit(); if(e.key === 'Escape') { closeModal(); } });
                cancel.addEventListener('click', ()=> closeModal());
                // ensure the input can be typed into (delay a tick to allow focus)
                setTimeout(()=>{ try{ input.focus(); input.select(); }catch(e){} }, 50);
            }
        })();
        </script>
    </body>
</html>